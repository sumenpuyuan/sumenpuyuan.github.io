---
title: vijosP1006晴天小猪历险记
categories:
  - 算法
date: 2018-11-01 21:08:25
tags:
---
#背景#
在很久很久以前，有一个动物村庄，那里是猪的乐园（^_^），村民们勤劳、勇敢、善良、团结……
不过有一天，最小的小小猪生病了，而这种病是极其罕见的，因此大家都没有储存这种药物。所以晴天小猪自告奋勇，要去采取这种药草。于是，晴天小猪的传奇故事便由此展开……

#描述#
这一天，他来到了一座深山的山脚下，因为只有这座深山中的一位隐者才知道这种药草的所在。但是上山的路错综复杂，由于小小猪的病情，晴天小猪想找一条需时最少的路到达山顶，但现在它一头雾水，所以向你求助。

山用一个三角形表示，从山顶依次向下有1段、2段、3段等山路，每一段用一个数字T（1<=T<=100）表示，代表晴天小猪在这一段山路上需要爬的时间，每一次它都可以朝左、右、左上、右上四个方向走。山是环形的。（**注意**：在任意一层的第一段也可以走到本层的最后一段或上一层的最后一段）。

晴天小猪从山的左下角出发，目的地为山顶，即隐者的小屋。

★★★**本题为vijos早年陈题，描述晦涩，现重新描述题面如下**★★★
有一个数字三角形，共nn行，依次编号为第一行，第二行至第nn行。其中第ii行有ii个数字，位置依次记为(i,1),(i,2)(i,1),(i,2)到(i,i)(i,i)。
现在从第nn层的第一个位置出发（即(n,1)(n,1)），每一步移到相邻的，且行编号小于或等于当前行编号的一个位置中，直到(1,1)(1,1)结束，在不重复经过任何位置的情形下，路过的所有位置（包括端点）的对应数字之和最小。

下面详细定义相邻关系。
同一层内连续的两个位置相邻，特别的有每一层第一个位置与最后一个位置相邻。
对于位置(i,j)(i,j)，它与(i-1,j-1)(i−1,j−1)以及(i-1,j)(i−1,j)相邻，特别的(i,1)(i,1)与(i-1,i-1)(i−1,i−1)相邻，且(i,i)(i,i)与(i-1,1)(i−1,1)相邻。

#格式#
##输入格式##
第一行有一个数n（2<=n<=1000），表示山的高度。

从第二行至第n+1行，第i+1行有i个数，每个数表示晴天小猪在这一段山路上需要爬的时间。

##输出格式##
一个数，即晴天小猪所需要的最短时间。

##样例1##
样例输入1
5

1

2 3

4 5 6

10 1 7 8

1 1 4 5 6

样例输出1

10

限制

各个测试点1s


提示

在山的两侧的走法略有特殊，请自己模拟一下，开始我自己都弄错了……

来源
Sunnypig

f[i][j]表示第i行第j个点到目标终点(1,1)的最小时间

则转换为数字三角形问题，但是只是多了几种走法，不断更新最小值就好了

但是问题就来了，这样动态规划具有最优子结构吗？

注意这是个环形走法

答案是不成立于的，怎么说？

我们来看一下这样一个例子，假设某个数据的第某层的时间为

1，1，1，1，1，1

而从下往上推上来一开始的初值f[][]分别为

1，2，4，3，9，10

那么我们先进行第一次同行内从左往右的更新的递推(可以看代码内的推法)

则有更新为

1，2，3，3，4，5

再从右往左更新推一遍

1，2，3，3，4，2(左端的1可以走到右端来更新了右端的时间)

那么这样就完了吗？不，我们可以发现我们可以用新更新的2去更新推出更优的解

则应该为

1，2，3，3，3，2

所以从这个样例中我们可以看出一次两边推根本的不出最优解

为什么呢？

我们看某次往一边推，由于是环形，所以可能从右向左推，用第一个更新了最右端的那个点

但是最右端的那个点在更新之前已经推完了右边数的第二个点

就是新更新的这个右端点并没有用来当作"下家"来更新别的点使别的点更优

同理从左往右也是一样

那么怎么办呢？

我们可以推两遍，这样假如更新了某个端点的值，在下一次递推时一定能用来作为"下家"尝试再更新别的点

那么这样问题就解决了

我们总结一下做法

首先每个点的初值为从下一层走到这一层的两个更优解

然后我们在同层迭代递推，左推一遍右推一遍，然后再重复推一遍

问题就解决了，so easy

Explanation: [4,-1,2,1] has the largest sum = 6.
```cpp
#include<cstdio>
#define MAXN 1010
#define INF 2000000010
int Min(int a,int b){return a<b?a:b;}
int road[MAXN][MAXN];
int f[MAXN][MAXN];
int n;
int main()
{
    scanf("%d",&n);
    int i,j;
    for(i=1;i<=n;++i)
        for(j=1;j<=i;++j)
            scanf("%d",&road[i][j]);
     
    f[n][1]=road[n][1];//开始节点
	//处理最后一层 最后一层不需要从上一层传数据
    for(i=2;i<=n;++i)f[n][i]=INF;
    for(i=2;i<=n;++i)f[n][i]=Min(f[n][i],f[n][i-1]+road[n][i]);
    for(i=n-1;i>=1;--i)f[n][i]=Min(f[n][i],f[n][i+1]+road[n][i]);
    f[n][n]=Min(f[n][n],f[n][1]+road[n][n]);
     
    for(i=n-1;i>=1;--i)
    {
		//先求出从上一层推出的最小值
        for(j=1;j<=i;++j)
            f[i][j]=Min(f[i+1][j],f[i+1][j+1])+road[i][j];
		//处理两个边界点
        f[i][i]=Min(f[i][i],f[i+1][1]+road[i][i]);
        f[i][1]=Min(f[i][1],f[i+1][i+1]+road[i][1]);
         
        for(j=2;j<=i;++j)f[i][j]=Min(f[i][j],f[i][j-1]+road[i][j]);//左
        f[i][1]=Min(f[i][1],f[i][i]+road[i][1]);
         
        for(j=i-1;j>=1;--j)f[i][j]=Min(f[i][j],f[i][j+1]+road[i][j]);//右
        f[i][i]=Min(f[i][i],f[i][1]+road[i][i]);
         
        for(j=2;j<=i;++j)f[i][j]=Min(f[i][j],f[i][j-1]+road[i][j]);//左
        f[i][1]=Min(f[i][1],f[i][i]+road[i][1]);
         
        for(j=i-1;j>=1;--j)f[i][j]=Min(f[i][j],f[i][j+1]+road[i][j]);//右
        f[i][i]=Min(f[i][i],f[i][1]+road[i][i]);
    }
     
    printf("%d\n",f[1][1]);
}
```